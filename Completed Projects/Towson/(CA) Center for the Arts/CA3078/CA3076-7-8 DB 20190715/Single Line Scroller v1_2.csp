#CATEGORY "0"

// No NVRAM storage needed.
#default_volatile

// If you are not interacing to the error log, comment out the below line.  It will prevent 
// the module from clearing the system error log when you drive the diClearBuff input high.
#define_constant CLEAR_ERROR_LOG_WITH_CLEAR_BUFFER	1

// Estimated size of a full error log:  125 characters line 1, 80 characters line 2 over 100 errors
// plus a little "more".
#define_constant BUFFER_SIZE	22000

// I set this to the "virtual line" length, how long the line is that can scroll left and right.
// I also kept it divisible by "aiScrollHorizontalBy" (which is 10d in the demo SIMPL program)
#define_constant MAX_LINE_LEN	130

// Inputs to the module.
digital_input diClearBuff;
digital_input diScrollUp;
digital_input diScrollDn;
digital_input diScrollLeft;
digital_input diScrollRight;
digital_input diJumpToTop;
digital_input diJumpToBottom;

// Outputs of the module.
analog_input aiScrollHorizontalBy;
analog_input aiNumCharactersOnDisplay;
STRING_INPUT siConsoleCommand$[100];
buffer_input biFromConsole$[BUFFER_SIZE];
digital_output atTop;
digital_output atBottom;
string_output soToDisplay$;
string_output soToConsole$;

// Variables global to the module.
string g_CurrentLine$[MAX_LINE_LEN];
string g_Blanks$[MAX_LINE_LEN];
string g_ConsoleBufferCopy$[BUFFER_SIZE];
integer g_BusyGettingData;
integer g_FirstCharInLine;
integer g_LastCharInLine;  
integer g_DataInitialized;
integer g_ScrollStartPosition;
integer g_CurrentLineLength;

function DebugPrint(string foo$, string label$)
{
	integer i, character;
	
	print("%s:",label$);
	for(i=1 to len(foo$))
	{
		character = byte(foo$, i);
		if(character >= 0x21 && character <= 0x7E)
			print("%c", character);
		else
			print("[%02X]", character);
	}
	print("\n");
}

function DisplayLine()
{
	integer LineLenToExtract;

	LineLenToExtract = g_LastCharInLine - g_FirstCharInLine;
    // Make sure it's not too big to copy into the temp line buffer.
	if( LineLenToExtract > MAX_LINE_LEN)
		LineLenToExtract = MAX_LINE_LEN;
		
	// Copy the contents to the Line buffer.
	if(LineLenToExtract > 0)
	{
		g_CurrentLine$ = mid(g_ConsoleBufferCopy$, g_FirstCharInLine, LineLenToExtract);
		while(byte(g_CurrentLine$, 1) = 32)		//Remove preceding spaces
    	{
    		g_CurrentLine$ = right(g_CurrentLine$, len(g_CurrentLine$) - 1);
    	}
	}
	else
	{
		g_CurrentLine$ = " ";
	}

	// Put the line buffer to the display.
	g_CurrentLineLength = len(g_CurrentLine$);
    soToDisplay$ = mid(g_CurrentLine$, g_ScrollStartPosition, aiNumCharactersOnDisplay);
}

function JumpToTop()
{
	integer LineLenToExtract;
	
	// Find the first CRLF pair that's after the real text.
	g_FirstCharInLine = 1;
	g_LastCharInLine = Find("\x0D\x0A", g_ConsoleBufferCopy$, g_FirstCharInLine);
	// If no terminator, use the full length of the string.
	// Add 1 to account for needing to get the last character (otherwise it's cut off).
	if(g_LastCharInLine = 0)
		g_LastCharInLine = len(g_ConsoleBufferCopy$)+1;
    
	atTop = 1;
	atBottom = 0;
	DisplayLine();
}

change biFromConsole$
{
	integer lastLoc;
	integer firstLoc;
	
	g_DataInitialized=0;
	g_BusyGettingData=1;
	g_ConsoleBufferCopy$ = gather(">", biFromConsole$);
	lastLoc = len(g_ConsoleBufferCopy$);
	firstLoc = 1;    

		
	// Skip over the prompt... (i.e. PRO2>)
	while(lastLoc>0 && byte(g_ConsoleBufferCopy$, lastLoc)>=0x20)
		lastLoc = lastLoc - 1;
				
	// Skip over the unprintable characters (CRLF pairs)
	while(lastLoc>0 && byte(g_ConsoleBufferCopy$, lastLoc)<0x20)
		lastLoc = lastLoc - 1;
	
	// Skip Over non-printables.
	firstLoc=1;	
	While(firstLoc<=lastLoc && byte(g_ConsoleBufferCopy$, firstLoc)<0x20)
		firstLoc = firstLoc + 1;    
				
	// Copy the string over to iterate through.
	if(lastLoc>firstLoc)
	{
		g_ConsoleBufferCopy$ = mid(g_ConsoleBufferCopy$, firstLoc, lastLoc - firstLoc + 1);
	}	
	else if((lastLoc < firstLoc) && (siConsoleCommand$ = "REPORTCRESNET\n"))
	{
		g_ConsoleBufferCopy$ = "No Network Devices Found";
		atTop = 1;
		atBottom = 1;

    }
    
	JumpToTop();
		
	g_BusyGettingData=0;
	g_DataInitialized=1;
}

push diClearBuff
{
	// If data is coming in from the console, don't interrupt it.
	if(g_BusyGettingData=1)
		return;

	g_DataInitialized=0;
	ClearBuffer(g_ConsoleBufferCopy$);
	ClearBuffer(biFromConsole$);

#if_defined CLEAR_ERROR_LOG_WITH_CLEAR_BUFFER
	soToConsole$ = "CLEARERR\n";
#endif
}

push diScrollUp
{
	integer cblen, LineLenToExtract;
	cblen = len(g_ConsoleBufferCopy$);   

	
	// If There's no data or data is coming in from the console, don't interrupt the operation.
	if(g_FirstCharInLine=1 || g_DataInitialized=0 || g_BusyGettingData=1)
		return;
	atTop = 0;
	atBottom = 0;		
	// The "g_FirstCharInLine" was on a CRLF pair, so skip past 2 to get the new first char.
	g_LastCharInLine =  ReverseFind("\x0D\x0A", g_ConsoleBufferCopy$, g_FirstCharInLine-1);
	g_FirstCharInLine =  ReverseFind("\x0D\x0A", g_ConsoleBufferCopy$, g_LastCharInLine-1);
	
	// Couldn't find it, point to the beginning of the string.  If we did find it, we should
	// advance +2 to skip that CRLF pair and find the real start of the string.
	if(g_FirstCharInLine = 0)
		{
		g_FirstCharInLine = 1;
		atTop = 1;
		}
		
	else
		g_FirstCharInLine = g_FirstCharInLine + 2;
	
	g_ScrollStartPosition=1; 

	DisplayLine();
}

push diScrollDn       
{
	integer cblen, LineLenToExtract;
	cblen = len(g_ConsoleBufferCopy$);   
	
	// If There's no data or data is coming in from the console, don't interrupt the operation.
	if(g_FirstCharInLine>=cblen || g_LastCharInLine>=cblen || g_DataInitialized=0 || g_BusyGettingData=1)
		return;
   	atTop = 0;
	atBottom = 0;
	// The "g_FirstCharInLine" was on a CRLF pair, so skip past 2 to get the new first char.
	g_FirstCharInLine = g_LastCharInLine + 2;	
	g_LastCharInLine =  Find("\x0D\x0A", g_ConsoleBufferCopy$, g_FirstCharInLine);
	// Can't find it, must be at the end of the data just use the string length.
	// Add 1 to account for needing to get the last character (otherwise it's cut off).
	if(g_LastCharInLine = 0)
		{
		g_LastCharInLine = len(g_ConsoleBufferCopy$)+1;
		atBottom = 1;
		}

	g_ScrollStartPosition=1;

	DisplayLine();
}

push diScrollLeft
{
	// If There's no data or data is coming in from the console, don't interrupt the operation.
	if(g_DataInitialized=0 || g_BusyGettingData=1)
		return;

	g_ScrollStartPosition = g_ScrollStartPosition - aiScrollHorizontalBy;
	if(g_ScrollStartPosition S< 0)
		g_ScrollStartPosition = 1;
	
	soToDisplay$ = mid(g_CurrentLine$, g_ScrollStartPosition, aiNumCharactersOnDisplay);		
}

push diScrollRight
{
	// If There's no data or data is coming in from the console, don't interrupt the operation.
	if(g_DataInitialized=0 || g_BusyGettingData=1)
		return; 

	if(g_CurrentLineLength > aiNumCharactersOnDisplay)
	{
		g_ScrollStartPosition = g_ScrollStartPosition + aiScrollHorizontalBy;
		if(g_ScrollStartPosition + aiNumCharactersOnDisplay > g_CurrentLineLength)
			g_ScrollStartPosition = g_CurrentLineLength - aiNumCharactersOnDisplay + 1;
		
		soToDisplay$ = mid(g_CurrentLine$, g_ScrollStartPosition, aiNumCharactersOnDisplay);		
	}
}

push diJumpToTop
{
	// If There's no data or data is coming in from the console, don't interrupt the operation.
	if(g_DataInitialized=0 || g_BusyGettingData=1)
		return;

	g_ScrollStartPosition=1; 

	JumpToTop();
}

push diJumpToBottom
{
	// If There's no data or data is coming in from the console, don't interrupt the operation.
	if(g_DataInitialized=0 || g_BusyGettingData=1)
		return; 

	g_LastCharInLine = len(g_ConsoleBufferCopy$);
	g_FirstCharInLine = ReverseFind("\x0D\x0A", g_ConsoleBufferCopy$, g_LastCharInLine);
	// Add 1 So display works properly.
	g_LastCharInLine = g_LastCharInLine + 1;
	if(g_FirstCharInLine = 0)
		g_FirstCharInLine = 1;
	else
		g_FirstCharInLine = g_FirstCharInLine + 2;

	g_ScrollStartPosition=1;
	atTop = 0;
	atBottom = 1;
	DisplayLine();
}

function main()
{
    integer i;
	
	g_BusyGettingData=0;
	g_DataInitialized=0;
	g_ScrollStartPosition=1;
	g_Blanks$ = "";
	atTop = 1;
	atBottom = 0;
	for(i = 1 to MAX_LINE_LEN)
		g_Blanks$ = g_Blanks$ + " ";
}
